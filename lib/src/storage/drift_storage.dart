import 'package:drift/drift.dart';
import '../core/synapse_entity.dart';
import 'synapse_storage.dart';

/// Feature 19: Drift (SQLite) Storage Driver.
/// Allows using SynapseLink with a robust SQL database.
/// 
/// T: The Synapse Entity
/// D: The Drift Data Class (generated by Drift)
/// C: The Drift Companion Class (generated by Drift)
class DriftStorage<T extends SynapseEntity, D, C extends UpdateCompanion<D>> implements SynapseStorage<T> {
  final DatabaseConnectionUser database;
  final TableInfo<Table, D> table;
  
  /// Converter functions to bridge Synapse Entity <-> Drift Class
  final C Function(T entity) toCompanion;
  final T Function(D data) fromData;

  DriftStorage({
    required this.database,
    required this.table,
    required this.toCompanion,
    required this.fromData,
  });

  @override
  Future<void> write(T entity) async {
    final companion = toCompanion(entity);
    await database.into(table).insertOnConflictUpdate(companion);
  }

  @override
  Future<T?> read(String id) async {
    // Assuming the table has a primary key named 'id' that matches the Entity ID.
    // Since Drift is type-safe, we query based on the id column.
    final query = database.select(table)..where((tbl) {
        // We assume the first column is the ID or user must provide a specific query
        // This is a generic abstraction, so we rely on custom queries if needed.
        // For standard Synapse, we expect a text ID.
        return (tbl as dynamic).id.equals(id); 
    });
    
    final result = await query.getSingleOrNull();
    return result != null ? fromData(result) : null;
  }

  @override
  Future<List<T>> readAll() async {
    final results = await database.select(table).get();
    return results.map(fromData).toList();
  }

  @override
  Future<void> delete(String id) async {
    await (database.delete(table)..where((tbl) => (tbl as dynamic).id.equals(id))).go();
  }

  @override
  Future<void> clear() async {
    await database.delete(table).go();
  }

  @override
  Future<void> close() async {
    // We typically don't close the entire DB here as it might be used by other tables.
    // Keeping it empty or strictly closing if this storage owns the DB.
  }
}